# AI Fabrix Miso Client SDK - Cursor Rules (Python)

## Project Overview
This is the AI Fabrix Miso Client SDK - a Python SDK for authentication, authorization, and logging with the Miso Controller. The SDK uses:
- Client token authentication (automatic via interceptors)
- User token authentication (Bearer tokens)
- Redis caching for roles/permissions (with controller fallback)
- httpx for HTTP communication
- PyJWT for JWT token decoding
- Pydantic for data validation

## Architecture Patterns

### Service Layer
- All services are in `miso_client/services/`
- Services receive `HttpClient` and `RedisService` as dependencies
- Services use `http_client.config` (public readonly property) for configuration access
- Services follow this pattern:
  ```python
  class ServiceName:
      def __init__(self, http_client: HttpClient, redis: RedisService):
          self.config = http_client.config  # Access via public property
          self.http_client = http_client
          self.redis = redis
  ```

### HTTP Client Pattern
- `HttpClient` wraps `InternalHttpClient` and adds ISO 27001 compliant audit logging
- `InternalHttpClient` manages client token automatically via httpx interceptors
- Client token is fetched from `/api/auth/token` using `clientId` and `clientSecret`
- Client token is sent as `x-client-token` header (lowercase)
- User tokens are sent as `Authorization: Bearer <token>`
- Always use `authenticated_request()` for user-authenticated requests
- Use `request()` for unauthenticated requests (client token is automatic)
- All HTTP requests are automatically audited with data masking (ISO 27001 compliant)

### Token Management
- **Client Token**: Automatically fetched and refreshed by `InternalHttpClient` via interceptor
  - Fetched from `POST /api/auth/token` with `X-Client-Id` and `X-Client-Secret`
  - Stored in memory with expiration tracking
  - Added to all requests as `x-client-token` header (lowercase)
  - Refreshed automatically when expired or on 401 errors
- **User Token**: Provided by application, sent as `Authorization: Bearer <token>`
- Never expose `clientId` or `clientSecret` to the client application - only the client token

### API Endpoints
All controller endpoints use `/api` prefix:
- `/api/auth/login` - User login
- `/api/auth/logout` - User logout
- `/api/auth/validate` - Validate user token
- `/api/auth/user` - Get user info
- `/api/auth/token` - Get client token (uses X-Client-Id/X-Client-Secret)
- `/api/auth/roles` - Get user roles
- `/api/auth/roles/refresh` - Refresh user roles
- `/api/auth/permissions` - Get user permissions
- `/api/auth/permissions/refresh` - Refresh user permissions
- `/api/logs` - Send logs

### JWT Token Handling
- Always use `jwt.decode()` (not verify - we don't have the secret)
- Extract userId from multiple possible fields: `sub`, `userId`, `user_id`, `id`
- Handle None/empty decoded tokens gracefully
- JWT context extraction pattern:
  ```python
  def extract_user_id_from_token(token: str) -> Optional[str]:
      try:
          decoded = jwt.decode(token, options={"verify_signature": False})
          if not decoded:
              return None
          return decoded.get("sub") or decoded.get("userId") or decoded.get("user_id") or decoded.get("id")
      except Exception:
          return None
  ```

### Redis Caching Pattern
- Always check `redis.is_connected()` before using Redis
- Cache keys format: `roles:{userId}` or `permissions:{userId}`
- Cache format: `json.dumps({"roles": [...], "timestamp": time.time()})`
- Default TTL: 900 seconds (15 minutes)
- Always fallback to controller when Redis fails
- Pattern:
  ```python
  if cache_key and self.redis.is_connected():
      cached = await self.redis.get(cache_key)
      if cached:
          try:
              parsed = json.loads(cached)
              return parsed.get("roles", [])
          except Exception:
              logger.warning("Failed to parse cached data")
  # Fallback to controller...
  ```

### Data Masking (ISO 27001 Compliance)
- All HTTP requests are automatically audited with sensitive data masked
- Use `DataMasker` to mask sensitive fields before logging
- Sensitive endpoints (`/api/logs`, `/api/auth/token`) are excluded from audit logging
- Configuration via `sensitive_fields_config.json` or environment variable `MISO_SENSITIVE_FIELDS_CONFIG`

## Code Style

### Python Conventions
- Use Python 3.8+ type hints throughout
- Use `strict: true` mypy configuration (where possible)
- Prefer Pydantic models over dataclasses for public APIs
- Use `snake_case` for functions, methods, and variables
- Use `PascalCase` for classes
- Use `UPPER_SNAKE_CASE` for constants
- Private methods/properties: prefix with `_` (single underscore)
- File names: `snake_case.py` matching module name

### Type Hints
- Always use type hints for function parameters and return types
- Use `Optional[T]` for nullable types
- Use `Dict[str, Any]` for dictionary types
- Use `List[T]` for list types
- Use `Union[T, U]` for union types (or `|` in Python 3.10+)
- Import types from `typing` module when needed

### Error Handling
- Services should return empty lists `[]` on errors (for get methods)
- Use try-except for all async operations
- Log errors with appropriate log level (`logger.error`, `logger.warning`)
- Never raise uncaught errors from service methods (return defaults instead)
- Pattern:
  ```python
  try:
      # operation
  except Exception as error:
      logger.error("Operation failed", exc_info=error)
      return []  # or appropriate default
  ```

### Async/Await
- Always use async/await, never raw coroutines
- Always use try-except with async operations
- Methods that return lists should return empty list on error
- Methods that return objects/None should return None on error
- Use `asyncio.gather()` for concurrent operations when appropriate
- Use async context managers (`async with`) for resource management

### Docstrings
- Use Google-style docstrings for all public methods
- Include Args, Returns, Raises sections
- Include examples for complex methods
- Pattern:
  ```python
  def method_name(self, param: str) -> Optional[str]:
      """
      Brief description of the method.

      Args:
          param: Description of parameter

      Returns:
          Description of return value, or None if not found

      Raises:
          CustomError: Description of when this error is raised
      """
  ```

## Testing Conventions

### Test File Structure
- Test files mirror source structure: `tests/unit/test_service_name.py`
- Use pytest for testing
- Use pytest-asyncio for async tests
- Mock all external dependencies (httpx, redis, PyJWT)
- Mock JWT decode: `mocker.patch('miso_client.utils.jwt_tools.decode_token', return_value={'sub': '123'})`
- Test both success and error paths
- Test cache hits and misses

### Mock Patterns
- Mock HttpClient: `mock_http_client = mocker.Mock(spec=HttpClient)`
- Mock Redis: `mock_redis = mocker.Mock(spec=RedisService)`
- Mock JWT: `mocker.patch('miso_client.utils.jwt_tools.decode_token')`
- Mock httpx client: `mocker.patch('httpx.AsyncClient')`
- Use pytest fixtures for common mocks

### Test Coverage
- Aim for 80%+ branch coverage
- Test edge cases (None tokens, empty lists, cache failures)
- Test JWT decode failures
- Test Redis connection failures
- Test HTTP fallbacks

### Async Testing
- Use `@pytest.mark.asyncio` for async test functions
- Use `await` in async tests
- Mock async methods with `mocker.patch('module.async_method', return_value=...)` or `AsyncMock`

## File Organization

### Source Structure
```
miso_client/
  __init__.py           # Main MisoClient class exports
  services/             # Service layer (auth, roles, permissions, logger, redis)
  utils/                # Utilities (http_client, internal_http_client, config_loader, data_masker)
  models/               # Pydantic models (config, error_response, filter, pagination, sort)
  errors.py             # Exception classes
```

### Import Order
1. Standard library imports
2. Third-party dependencies (httpx, redis, PyJWT, pydantic)
3. Internal models
4. Internal utilities
5. Internal services
6. Relative imports

### Export Strategy
- Export main class from `miso_client/__init__.py`
- Export models from `miso_client/models/__init__.py` (if needed)
- Don't export internal utilities/services directly unless needed
- Use `__all__` to control public API exports

## Configuration

### Config Types
- All config in `miso_client/models/config.py`
- Use `load_config()` helper to load from .env
- Config is readonly after initialization (use Pydantic models)
- Access via `http_client.config` (public readonly property)

### Environment Variables
- `MISO_CLIENTID` - Client ID
- `MISO_CLIENTSECRET` - Client secret
- `MISO_CONTROLLER_URL` - Controller base URL
- `REDIS_HOST` - Redis host (optional)
- `REDIS_PORT` - Redis port (optional)
- `MISO_LOG_LEVEL` - Logging level (optional: debug, info, warn, error)
- `ENCRYPTION_KEY` - Encryption key for encryption service (optional)
- `API_KEY` - API key for testing (optional, bypasses OAuth2)
- `MISO_SENSITIVE_FIELDS_CONFIG` - Path to sensitive fields config JSON (optional)

## Common Patterns

### Service Method Pattern
```python
async def get_something(self, token: str) -> List[Type]:
    try:
        # Extract userId from token if possible
        user_id = self._extract_user_id_from_token(token)
        cache_key = f"cache:{user_id}" if user_id else None

        # Try cache first
        if cache_key and self.redis.is_connected():
            cached = await self.redis.get(cache_key)
            if cached:
                try:
                    parsed = json.loads(cached)
                    return parsed.get("data", [])
                except Exception:
                    logger.warning("Failed to parse cached data")

        # Fallback to controller
        if not user_id:
            user_info = await self.http_client.authenticated_request(
                "POST",
                "/api/auth/validate",
                token
            )
            user_id = user_info.get("user", {}).get("id")
            if not user_id:
                return []

        # Fetch from controller
        result = await self.http_client.authenticated_request(
            "GET",
            "/api/endpoint",
            token
        )

        # Cache result
        if user_id and self.redis.is_connected():
            await self.redis.set(
                cache_key,
                json.dumps({"data": result, "timestamp": time.time()}),
                ttl=900
            )

        return result.get("data", [])
    except Exception as error:
        logger.error("Operation failed", exc_info=error)
        return []
```

### Logger Chain Pattern
```python
# Fluent API
await logger_service \
    .with_context({"action": "test"}) \
    .with_token("jwt-token") \
    .add_user("user-123") \
    .info("Message")

# Error handling in logger should be silent (catch and swallow)
```

### Client Token Fetch Pattern
```python
# In InternalHttpClient
async def _fetch_client_token(self) -> str:
    # Use temporary httpx client to avoid interceptor recursion
    async with httpx.AsyncClient(
        base_url=self.config.controller_url,
        timeout=30.0,
        headers={
            "Content-Type": "application/json",
            "X-Client-Id": self.config.client_id,
            "X-Client-Secret": self.config.client_secret
        }
    ) as client:
        response = await client.post("/api/auth/token")
        response.raise_for_status()
        # Store token and expiration...
```

### HTTP Client with Filters Pattern
```python
# Use FilterBuilder for dynamic filtering
from miso_client import FilterBuilder

filter_builder = FilterBuilder() \
    .add("status", "eq", "active") \
    .add("region", "in", ["eu", "us"])

response = await http_client.get_with_filters(
    "/api/items",
    filter_builder=filter_builder
)

# Or use FilterQuery for complete queries
from miso_client import FilterQuery, FilterOption

filter_query = FilterQuery(
    filters=[
        FilterOption(field="status", op="eq", value="active")
    ],
    sort=["-updated_at"],
    page=1,
    page_size=25
)
```

## Security Guidelines
- Never log `clientId` or `clientSecret`
- Never expose client credentials to client-side code
- Mask sensitive data in logs (use DataMasker)
- Client token is not a Bearer token - it goes in `x-client-token` header
- User token goes in `Authorization: Bearer <token>` header
- All HTTP requests are automatically audited with ISO 27001 compliant data masking

## Performance Guidelines
- Always use Redis cache when available
- Extract userId from JWT to avoid unnecessary validate API calls
- Cache roles and permissions with TTL (default 15 min)
- Use connection pooling for Redis
- Handle Redis failures gracefully with controller fallback
- Use async/await for all I/O operations

## Documentation
- Use Google-style docstrings for public methods
- Include parameter types and return types in docstrings
- Document error conditions in Raises section
- Add examples in docstrings for complex methods
- Use type hints throughout (enables better IDE support)

## Dependencies
- `pydantic`: Data validation and models
- `httpx`: HTTP client (async)
- `redis[hiredis]`: Redis client
- `PyJWT`: JWT decoding (NOT verification)
- `cryptography`: Encryption/decryption (AES-256-GCM)
- `python-dotenv`: Environment variable loading (dev only)

## When Adding New Features
1. Update models in `miso_client/models/` first
2. Add service method if needed
3. Update `miso_client/__init__.py` to expose public API
4. Write comprehensive tests
5. Update documentation in `docs/`
6. Maintain 80%+ branch coverage
7. Add type hints throughout
8. Add Google-style docstrings

## Critical Rules
- ✅ Always use `/api` prefix for controller endpoints
- ✅ Client token: `x-client-token` header (lowercase)
- ✅ User token: `Authorization: Bearer <token>`
- ✅ Extract userId from JWT before calling validate when possible
- ✅ Always check `redis.is_connected()` before Redis operations
- ✅ Return empty list `[]` on service method errors
- ✅ Use public readonly `config` property, not private
- ✅ Mock JWT decode in tests: `mocker.patch('miso_client.utils.jwt_tools.decode_token')`
- ✅ Use temporary httpx client for client token fetch (avoid recursion)
- ✅ Use snake_case for all functions, methods, and variables
- ✅ Use PascalCase for all classes
- ✅ Use async/await for all I/O operations
- ✅ Use type hints throughout
- ✅ Add Google-style docstrings for public methods
- ✅ All HTTP requests are automatically audited with ISO 27001 compliant data masking
- ❌ Never expose `clientId` or `clientSecret` in client code
- ❌ Never raise uncaught errors from service methods (return defaults)
- ❌ Never use `X-Client-Token` (use lowercase `x-client-token`)
- ❌ Don't verify JWT tokens (only decode - no secret available)
- ❌ Don't use camelCase (use snake_case for Python)
- ❌ Don't skip type hints
- ❌ Don't skip docstrings for public methods

