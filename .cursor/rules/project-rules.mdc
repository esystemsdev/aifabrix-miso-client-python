---
alwaysApply: true
---
# AI Fabrix Miso Client SDK - Cursor Rules - ISO 27001 Compliant Development Standards

## Project Overview

This is the AI Fabrix Miso Client SDK - a Python SDK for authentication, authorization, and logging with the Miso Controller. The SDK provides:
- **Authentication** - User login, logout, token validation, user info
- **Authorization** - Role and permission management with Redis caching
- **Logging** - ISO 27001 compliant audit logging with configurable levels
- **Encryption** - AES-256-GCM encryption/decryption service
- **Caching** - Redis caching with controller fallback

Technologies:
- Python 3.8+ with type hints
- httpx for HTTP communication (async)
- redis[hiredis] for Redis caching
- PyJWT for JWT token decoding (NOT verification)
- Pydantic for data validation
- pytest for testing
- cryptography for encryption/decryption

## Architecture Patterns

### Service Layer
- All services are in `miso_client/services/`
- Services receive `HttpClient` and `RedisService` as dependencies
- Services use `http_client.config` (public readonly property) for configuration access
- Services follow this pattern:
  ```python
  class ServiceName:
      def __init__(self, http_client: HttpClient, redis: RedisService):
          self.config = http_client.config  # Access via public property
          self.http_client = http_client
          self.redis = redis
  ```

### HTTP Client Pattern
- `HttpClient` wraps `InternalHttpClient` and adds ISO 27001 compliant audit logging
- `InternalHttpClient` manages client token automatically via httpx interceptors
- Client token is fetched from `/api/auth/token` using `clientId` and `clientSecret`
- Client token is sent as `x-client-token` header (lowercase)
- User tokens are sent as `Authorization: Bearer <token>`
- Always use `authenticated_request()` for user-authenticated requests
- Use `request()` for unauthenticated requests (client token is automatic)
- All HTTP requests are automatically audited with data masking (ISO 27001 compliant)
- Use `get_with_filters()` for filtered GET requests with FilterBuilder
- Use `get_paginated()` for paginated GET requests
- Use `build_query_string()` to convert FilterQuery to URL query string

### Token Management
- **Client Token**: Automatically fetched and refreshed by `InternalHttpClient` via interceptor
  - Fetched from `POST /api/auth/token` with `X-Client-Id` and `X-Client-Secret`
  - Stored in memory with expiration tracking
  - Added to all requests as `x-client-token` header (lowercase)
  - Refreshed automatically when expired or on 401 errors
- **User Token**: Provided by application, sent as `Authorization: Bearer <token>`
- Never expose `clientId` or `clientSecret` to the client application - only the client token

### API Endpoints
All controller endpoints use `/api` prefix:
- `/api/auth/login` - User login
- `/api/auth/logout` - User logout
- `/api/auth/validate` - Validate user token
- `/api/auth/user` - Get user info
- `/api/auth/token` - Get client token (uses X-Client-Id/X-Client-Secret)
- `/api/auth/roles` - Get user roles
- `/api/auth/roles/refresh` - Refresh user roles
- `/api/auth/permissions` - Get user permissions
- `/api/auth/permissions/refresh` - Refresh user permissions
- `/api/logs` - Send logs

### JWT Token Handling
- Always use `jwt.decode()` (not verify - we don't have the secret)
- Extract userId from multiple possible fields: `sub`, `userId`, `user_id`, `id`
- Handle None/empty decoded tokens gracefully
- JWT context extraction pattern:
  ```python
  def extract_user_id_from_token(token: str) -> Optional[str]:
      try:
          decoded = jwt.decode(token, options={"verify_signature": False})
          if not decoded:
              return None
          return decoded.get("sub") or decoded.get("userId") or decoded.get("user_id") or decoded.get("id")
      except Exception:
          return None
  ```

### Redis Caching Pattern
- Always check `redis.is_connected()` before using Redis
- Cache keys format: `roles:{userId}` or `permissions:{userId}`
- Cache format: `json.dumps({"roles": [...], "timestamp": time.time()})`
- Default TTL: 900 seconds (15 minutes)
- Always fallback to controller when Redis fails
- Pattern:
  ```python
  if cache_key and self.redis.is_connected():
      cached = await self.redis.get(cache_key)
      if cached:
          try:
              parsed = json.loads(cached)
              return parsed.get("roles", [])
          except Exception:
              logger.warning("Failed to parse cached data")
  # Fallback to controller...
  ```

### Data Masking (ISO 27001 Compliance)
- All HTTP requests are automatically audited with sensitive data masked
- Use `DataMasker` to mask sensitive fields before logging
- Sensitive endpoints (`/api/logs`, `/api/auth/token`) are excluded from audit logging
- Configuration via `sensitive_fields_config.json` or environment variable `MISO_SENSITIVE_FIELDS_CONFIG`

### API Data Conventions (camelCase)
- **All outgoing data must use camelCase naming convention**
  - All Pydantic model fields sent to API must be camelCase (e.g., `pageSize`, `totalItems`, `currentPage`, `userId`, `statusCode`, `correlationId`)
  - All JSON request bodies must use camelCase field names
  - All query parameters must use camelCase (e.g., `pageSize`, not `page_size`)
  - All response data from API is expected in camelCase format
- **Python code conventions remain snake_case** (functions, methods, variables, parameters)
- **Examples:**
  - Query parameters: `?page=1&pageSize=25` (not `page_size`)
  - Model fields: `FilterQuery(pageSize=25)` (not `page_size`)
  - JSON request body: `{"userId": "123", "applicationId": "app-1"}` (not `user_id`, `application_id`)
  - Response parsing: `response.meta.totalItems` (not `total_items`)

## Code Style

### Python Conventions
- Use Python 3.8+ type hints throughout
- Use `strict: true` mypy configuration (where possible)
- Prefer Pydantic models over dataclasses for public APIs
- Use `snake_case` for functions, methods, and variables
- Use `PascalCase` for classes
- Use `UPPER_SNAKE_CASE` for constants
- Private methods/properties: prefix with `_` (single underscore)
- File names: `snake_case.py` matching module name

### Type Hints
- Always use type hints for function parameters and return types
- Use `Optional[T]` for nullable types
- Use `Dict[str, Any]` for dictionary types
- Use `List[T]` for list types
- Use `Union[T, U]` for union types (or `|` in Python 3.10+)
- Import types from `typing` module when needed

### Error Handling
- **RFC 7807 Compliance**: All error responses follow RFC 7807 Problem Details for HTTP APIs standard
- Services should return empty lists `[]` on errors (for get methods)
- Services should return `None` on errors (for methods that return single objects)
- Use try-except for all async operations
- Log errors with appropriate log level (`logger.error`, `logger.warning`)
- Never raise uncaught errors from service methods (return defaults instead)
- Use `exc_info=error` in logger.error() for proper stack traces
- Handle specific exceptions when possible (but still catch all for safety)
- Pattern:
  ```python
  try:
      # operation
  except Exception as error:
      logger.error("Operation failed", exc_info=error)
      return []  # or appropriate default (None for objects)
  ```
- **Error Classes**:
  - `MisoClientError`: Base exception with `error_response` field (ErrorResponse object)
  - `ApiErrorException`: Exception for camelCase error responses (use `handleApiError()`)
  - `AuthenticationError`: Raised when authentication fails
  - `AuthorizationError`: Raised when authorization check fails
  - `ConnectionError`: Raised when connection to controller or Redis fails
  - `ConfigurationError`: Raised when configuration is invalid
- **ErrorResponse Model** (RFC 7807-style):
  - Fields: `errors` (List[str]), `type` (str), `title` (Optional[str]), `statusCode` (int), `instance` (Optional[str]), `correlationId` (Optional[str])
  - All fields use camelCase naming convention
  - Error type URIs follow pattern: `/Errors/{ErrorType}` (e.g., `/Errors/BadRequest`)
- **Error Utilities**:
  - `transformError()` / `transform_error_to_snake_case()`: Transforms error dict to ErrorResponse (expects camelCase data)
  - `handleApiError()`: Raises `ApiErrorException` from camelCase API response (preferred)
  - `handle_api_error_snake_case()`: Returns `MisoClientError` (legacy, for backward compatibility)
- **Error Handling Pattern**:
  ```python
  from miso_client import MisoClientError, ApiErrorException, ErrorResponse
  
  try:
      result = await http_client.authenticated_request("GET", "/api/endpoint", token)
  except MisoClientError as error:
      # Access structured error response
      if error.error_response:
          logger.error("API error", extra={
              "statusCode": error.error_response.statusCode,
              "type": error.error_response.type,
              "errors": error.error_response.errors,
              "correlationId": error.error_response.correlationId
          })
      return []  # or None for single objects
  ```
- Raise custom exceptions (AuthenticationError, AuthorizationError, etc.) only from HTTP client layer
- Services should catch and handle exceptions, returning defaults instead of propagating
- Never expose stack traces or internal error details to client code
- Always log errors with full context (status code, error type, correlation ID, etc.)

### Async/Await
- Always use async/await, never raw coroutines
- Always use try-except with async operations
- Methods that return lists should return empty list on error
- Methods that return objects/None should return None on error
- Use `asyncio.gather()` for concurrent operations when appropriate
- Use async context managers (`async with`) for resource management

### Docstrings
- Use Google-style docstrings for all public methods
- Include Args, Returns, Raises sections
- Include examples for complex methods
- Pattern:
  ```python
  def method_name(self, param: str) -> Optional[str]:
      """
      Brief description of the method.

      Args:
          param: Description of parameter

      Returns:
          Description of return value, or None if not found

      Raises:
          CustomError: Description of when this error is raised
      """
  ```

## Testing Conventions

### Test File Structure
- Test files mirror source structure: `tests/unit/test_service_name.py`
- Use pytest for testing
- Use pytest-asyncio for async tests
- Mock all external dependencies (httpx, redis, PyJWT)
- Mock JWT decode: `mocker.patch('miso_client.utils.jwt_tools.decode_token', return_value={'sub': '123'})`
- Test both success and error paths
- Test cache hits and misses

### Mock Patterns
- Mock HttpClient: `mock_http_client = mocker.Mock(spec=HttpClient)`
  - Mock async methods: `mock_http_client.authenticated_request = AsyncMock(return_value={...})`
  - Mock properties: `mock_http_client.config = config`
- Mock Redis: `mock_redis = mocker.Mock(spec=RedisService)`
  - Mock async methods: `mock_redis.get = AsyncMock(return_value=...)`
  - Mock sync methods: `mock_redis.is_connected = Mock(return_value=True)`
- Mock JWT: `mocker.patch('miso_client.utils.jwt_tools.decode_token', return_value={'sub': '123'})`
  - Always mock at the module level where decode_token is imported
  - Return dict with userId fields: `sub`, `userId`, `user_id`, or `id`
- Mock httpx client: `mocker.patch('httpx.AsyncClient')`
  - Use `AsyncMock` for httpx.AsyncClient methods
  - Mock response objects: `mocker.Mock(status_code=200, json=AsyncMock(return_value={...}))`
- Use pytest fixtures for common mocks (see `conftest.py` for examples)
- Use `mocker.patch.object()` for patching specific instances
- Use `mocker.patch.multiple()` for patching multiple attributes
- Pattern for mocking httpx:
  ```python
  mock_response = mocker.Mock()
  mock_response.status_code = 200
  mock_response.json = AsyncMock(return_value={"data": []})
  mock_response.raise_for_status = mocker.Mock()
  
  mock_client = mocker.Mock()
  mock_client.get = AsyncMock(return_value=mock_response)
  mock_client.post = AsyncMock(return_value=mock_response)
  mocker.patch('httpx.AsyncClient', return_value=mock_client)
  ```

### Test Coverage
- Aim for 80%+ branch coverage
- Test edge cases (None tokens, empty lists, cache failures)
- Test JWT decode failures
- Test Redis connection failures
- Test HTTP fallbacks

### Async Testing
- Use `@pytest.mark.asyncio` for async test functions
- Use `await` in async tests
- Mock async methods with `mocker.patch('module.async_method', return_value=...)` or `AsyncMock`
- Use `pytest-asyncio` fixture for async context managers
- Test async context managers (`async with`) separately when relevant
- Mock `httpx.AsyncClient` for HTTP client tests
- Use `AsyncMock` from `unittest.mock` for async method mocks:
  ```python
  from unittest.mock import AsyncMock
  mock_method = AsyncMock(return_value={"data": []})
  ```

## File Organization

### Source Structure
```
miso_client/
  __init__.py           # Main MisoClient class exports
  services/             # Service layer (auth, roles, permissions, logger, redis)
  utils/                # Utilities (http_client, internal_http_client, config_loader, data_masker)
  models/               # Pydantic models (config, error_response, filter, pagination, sort)
  errors.py             # Exception classes
```

### Import Order
1. Standard library imports
2. Third-party dependencies (httpx, redis, PyJWT, pydantic)
3. Internal models
4. Internal utilities
5. Internal services
6. Relative imports

### Export Strategy
- Export main class from `miso_client/__init__.py`
- Export models from `miso_client/models/__init__.py` (if needed)
- Don't export internal utilities/services directly unless needed
- Use `__all__` to control public API exports

## Configuration

### Config Types
- All config in `miso_client/models/config.py`
- Use `load_config()` helper to load from .env
- Config is readonly after initialization (use Pydantic models)
- Access via `http_client.config` (public readonly property)

### Environment Variables
- `MISO_CLIENTID` - Client ID
- `MISO_CLIENTSECRET` - Client secret
- `MISO_CONTROLLER_URL` - Controller base URL
- `REDIS_HOST` - Redis host (optional)
- `REDIS_PORT` - Redis port (optional)
- `MISO_LOG_LEVEL` - Logging level (optional: debug, info, warn, error)
- `ENCRYPTION_KEY` - Encryption key for encryption service (optional)
- `API_KEY` - API key for testing (optional, bypasses OAuth2)
- `MISO_SENSITIVE_FIELDS_CONFIG` - Path to sensitive fields config JSON (optional)

## Common Patterns

### Service Method Pattern
```python
async def get_something(self, token: str) -> List[Type]:
    try:
        # Extract userId from token if possible
        user_id = self._extract_user_id_from_token(token)
        cache_key = f"cache:{user_id}" if user_id else None

        # Try cache first
        if cache_key and self.redis.is_connected():
            cached = await self.redis.get(cache_key)
            if cached:
                try:
                    parsed = json.loads(cached)
                    return parsed.get("data", [])
                except Exception:
                    logger.warning("Failed to parse cached data")

        # Fallback to controller
        if not user_id:
            user_info = await self.http_client.authenticated_request(
                "POST",
                "/api/auth/validate",
                token
            )
            user_id = user_info.get("user", {}).get("id")
            if not user_id:
                return []

        # Fetch from controller
        result = await self.http_client.authenticated_request(
            "GET",
            "/api/endpoint",
            token
        )

        # Cache result
        if user_id and self.redis.is_connected():
            await self.redis.set(
                cache_key,
                json.dumps({"data": result, "timestamp": time.time()}),
                ttl=900
            )

        return result.get("data", [])
    except Exception as error:
        logger.error("Operation failed", exc_info=error)
        return []
```

### Logger Chain Pattern
```python
# Fluent API
await logger_service \
    .with_context({"action": "test"}) \
    .with_token("jwt-token") \
    .add_user("user-123") \
    .info("Message")

# Error handling in logger should be silent (catch and swallow)
```

### Error Handling Pattern
```python
from miso_client import MisoClientError, ApiErrorException, ErrorResponse
from miso_client.errors import AuthenticationError, AuthorizationError

# Service method error handling (returns defaults)
async def get_something(self, token: str) -> List[Type]:
    try:
        result = await self.http_client.authenticated_request(
            "GET",
            "/api/endpoint",
            token
        )
        return result.get("data", [])
    except MisoClientError as error:
        # Log structured error details
        if error.error_response:
            logger.error("API error", extra={
                "statusCode": error.error_response.statusCode,
                "type": error.error_response.type,
                "errors": error.error_response.errors,
                "correlationId": error.error_response.correlationId
            })
        return []  # Return default for get methods
    except Exception as error:
        logger.error("Unexpected error", exc_info=error)
        return []

# HTTP client error handling (raises exceptions)
from miso_client.utils.error_utils import handleApiError, transformError

try:
    response = await http_client.get("/api/endpoint")
except httpx.HTTPStatusError as e:
    if e.response.status_code >= 400:
        error_data = e.response.json()
        # Transform and raise ApiErrorException
        handleApiError(error_data, e.response.status_code, str(e.request.url))
except MisoClientError as error:
    # Handle MisoClientError with structured response
    if error.error_response:
        print(f"Error: {error.error_response.title}")
        print(f"Status: {error.error_response.statusCode}")
        print(f"Errors: {error.error_response.errors}")
        print(f"Correlation ID: {error.error_response.correlationId}")
    raise

# Error transformation
error_data = {
    "errors": ["Validation failed"],
    "type": "/Errors/Validation",
    "title": "Validation Error",
    "statusCode": 422,
    "correlationId": "req-123"
}
error_response = transformError(error_data)  # Returns ErrorResponse object
```

### Client Token Fetch Pattern
```python
# In InternalHttpClient
async def _fetch_client_token(self) -> str:
    # Use temporary httpx client to avoid interceptor recursion
    async with httpx.AsyncClient(
        base_url=self.config.controller_url,
        timeout=30.0,
        headers={
            "Content-Type": "application/json",
            "X-Client-Id": self.config.client_id,
            "X-Client-Secret": self.config.client_secret
        }
    ) as client:
        response = await client.post("/api/auth/token")
        response.raise_for_status()
        # Store token and expiration...
```

### HTTP Client with Filters Pattern
```python
# Use FilterBuilder for dynamic filtering
from miso_client import FilterBuilder, build_query_string

filter_builder = FilterBuilder() \
    .add("status", "eq", "active") \
    .add("region", "in", ["eu", "us"])

response = await http_client.get_with_filters(
    "/api/items",
    filter_builder=filter_builder
)

# Or use FilterQuery for complete queries with pagination and sort
from miso_client import FilterQuery, FilterOption, build_query_string

filter_query = FilterQuery(
    filters=[
        FilterOption(field="status", op="eq", value="active"),
        FilterOption(field="region", op="in", value=["eu", "us"])
    ],
    sort=["-updated_at", "created_at"],
    page=1,
    pageSize=25,
    fields=["id", "name", "status"]  # Optional field selection
)

# Build query string from FilterQuery
query_string = build_query_string(filter_query)
# Returns: "?filter=status:eq:active&filter=region:in:eu,us&sort=-updated_at&sort=created_at&page=1&pageSize=25"

# Use with pagination utilities
from miso_client import parse_pagination_params, create_paginated_list_response

params = {"page": "1", "pageSize": "25"}
current_page, page_size = parse_pagination_params(params)

# Parse existing filter params
from miso_client import parse_filter_params
filters = parse_filter_params({"filter": ["status:eq:active"]})

# Parse sort params
from miso_client import parse_sort_params
sort_options = parse_sort_params({"sort": ["-updated_at", "created_at"]})
```

### Pagination Pattern
```python
# Parse pagination from query parameters
from miso_client import parse_pagination_params, create_paginated_list_response

params = {"page": "1", "pageSize": "25"}
current_page, page_size = parse_pagination_params(params)

# Create paginated response (useful for testing/mocking)
items = [{"id": 1}, {"id": 2}]
response = create_paginated_list_response(
    items,
    total_items=120,
    current_page=1,
    page_size=25,
    type="item"
)

# Access response structure
# response.meta.totalItems  # 120
# response.meta.currentPage  # 1
# response.meta.pageSize  # 25
# response.data  # [{"id": 1}, {"id": 2}]

# Apply pagination to array locally (useful for testing)
from miso_client import apply_pagination_to_array
paginated_items = apply_pagination_to_array(all_items, page=1, page_size=25)
```

## Security Guidelines
- Never log `clientId` or `clientSecret`
- Never expose client credentials to client-side code
- Mask sensitive data in logs (use DataMasker)
- Client token is not a Bearer token - it goes in `x-client-token` header
- User token goes in `Authorization: Bearer <token>` header
- All HTTP requests are automatically audited with ISO 27001 compliant data masking
- **Error Handling Security**:
  - Never expose stack traces or internal error details to client code
  - Never expose sensitive information in error messages (database queries, internal codes, etc.)
  - Always log errors with full context (status code, error type, correlation ID) but sanitize before exposing
  - Use generic error messages for clients, detailed messages only in logs
  - Sanitize error messages before sending to clients (remove paths, internal IDs, etc.)
  - Always include correlation ID in error responses for tracing (from `error_response.correlationId`)

## Performance Guidelines
- Always use Redis cache when available
- Extract userId from JWT to avoid unnecessary validate API calls
- Cache roles and permissions with TTL (default 15 min)
- Use connection pooling for Redis
- Handle Redis failures gracefully with controller fallback
- Use async/await for all I/O operations

## Code Size Guidelines
- **File Size**: Keep source files under 500 lines
  - If a file exceeds 500 lines, consider splitting into multiple files
  - Extract related functionality into separate utility classes or modules
  - Use helper functions/classes to reduce file size
- **Method Size**: Keep methods under 20-30 lines
  - Break complex methods into smaller, focused helper methods
  - Each method should have a single responsibility
  - Use private helper methods (prefix with `_`) to extract logic from large methods
  - Consider using decorators or mixins for cross-cutting concerns
- **Exception**: Configuration files, type definitions, test files, and `__init__.py` files may exceed limits if needed
  - Models files can be longer if they define many related Pydantic models
  - Test files can exceed limits if comprehensive test coverage requires it
  - `__init__.py` can be longer if it exports many public APIs

## Documentation
- Use Google-style docstrings for all public methods and classes
- Include parameter types and return types in docstrings
- Document error conditions in Raises section
- Add examples in docstrings for complex methods
- Use type hints throughout (enables better IDE support)
- Document class-level attributes and properties

## Dependencies
- `pydantic`: Data validation and models
- `httpx`: HTTP client (async)
- `redis[hiredis]`: Redis client
- `PyJWT`: JWT decoding (NOT verification)
- `cryptography`: Encryption/decryption (AES-256-GCM)
- `python-dotenv`: Environment variable loading (dev only)

## When Adding New Features
1. Update models in `miso_client/models/` first
2. Add service method if needed
3. Update `miso_client/__init__.py` to expose public API
4. Write comprehensive tests
5. Update documentation in `docs/`
6. Maintain 80%+ branch coverage
7. Add type hints throughout
8. Add Google-style docstrings

## Common Pitfalls and Best Practices

### Token Handling
- ✅ Extract userId from JWT before calling validate when possible (avoids unnecessary API calls)
- ✅ Cache JWT decode results when processing multiple requests with same token
- ❌ Don't call validate endpoint if userId can be extracted from JWT
- ❌ Don't store tokens in logs or error messages

### Redis Caching
- ✅ Always check `redis.is_connected()` before Redis operations
- ✅ Use appropriate TTL (default 900 seconds / 15 minutes)
- ✅ Always fallback to controller when Redis fails
- ✅ Use proper cache key format: `roles:{userId}` or `permissions:{userId}`
- ❌ Don't fail requests if Redis is unavailable (gracefully fallback)

### Error Handling
- ✅ Return empty list `[]` on service method errors (for get methods)
- ✅ Return `None` on service method errors (for methods returning single objects)
- ✅ Use `exc_info=error` in logger.error() for proper stack traces
- ✅ Use RFC 7807-compliant ErrorResponse format (camelCase fields: `statusCode`, `correlationId`)
- ✅ Access structured error details via `error.error_response` (ErrorResponse object)
- ✅ Log errors with full context: status code, error type, correlation ID, errors list
- ✅ Use `handleApiError()` for raising `ApiErrorException` from API responses
- ✅ Use `transformError()` to convert error dicts to ErrorResponse objects
- ✅ Handle `MisoClientError` with structured `error_response` field
- ❌ Never raise uncaught errors from service methods (catch and return defaults)
- ❌ Don't expose internal error details to client code (stack traces, internal codes, etc.)
- ❌ Don't expose sensitive information in error messages (database queries, paths, etc.)
- ❌ Don't use snake_case for error response fields (use camelCase: `statusCode`, not `status_code`)
- ❌ Don't skip error logging (always log with context)

### HTTP Client
- ✅ Use temporary httpx client for client token fetch (avoid interceptor recursion)
- ✅ Always use `authenticated_request()` for user-authenticated requests
- ✅ Use `request()` for unauthenticated requests (client token is automatic)
- ✅ Use `get_with_filters()` for filtered requests
- ✅ Use `get_paginated()` for paginated requests
- ❌ Never use `X-Client-Token` (use lowercase `x-client-token`)
- ❌ Don't manually add client token header (it's automatic via interceptor)

### Testing
- ✅ Mock JWT decode: `mocker.patch('miso_client.utils.jwt_tools.decode_token')`
- ✅ Test both success and error paths
- ✅ Test cache hits and misses
- ✅ Use `AsyncMock` for async method mocks
- ❌ Don't forget to mock async methods as async (use AsyncMock)

## Critical Rules

### Must Do (✅)
- ✅ Always use `/api` prefix for controller endpoints
- ✅ Client token: `x-client-token` header (lowercase)
- ✅ User token: `Authorization: Bearer <token>`
- ✅ Extract userId from JWT before calling validate when possible
- ✅ Always check `redis.is_connected()` before Redis operations
- ✅ Return empty list `[]` on service method errors (get methods)
- ✅ Return `None` on service method errors (single object methods)
- ✅ Use public readonly `config` property, not private
- ✅ Mock JWT decode in tests: `mocker.patch('miso_client.utils.jwt_tools.decode_token')`
- ✅ Use temporary httpx client for client token fetch (avoid recursion)
- ✅ Use snake_case for all functions, methods, and variables
- ✅ Use PascalCase for all classes
- ✅ Use async/await for all I/O operations
- ✅ Use type hints throughout
- ✅ Add Google-style docstrings for all public methods and classes
- ✅ All HTTP requests are automatically audited with ISO 27001 compliant data masking
- ✅ Keep source files under 500 lines (with exceptions for models/tests)
- ✅ Keep methods under 20-30 lines (break into helper methods)
- ✅ Use RFC 7807-compliant ErrorResponse format (camelCase: `statusCode`, `correlationId`)
- ✅ Access structured errors via `error.error_response` (ErrorResponse object)
- ✅ Log errors with full context (status code, error type, correlation ID, errors list)
- ✅ Use `handleApiError()` for raising `ApiErrorException` from API responses

### Must Not Do (❌)
- ❌ Never expose `clientId` or `clientSecret` in client code
- ❌ Never raise uncaught errors from service methods (return defaults)
- ❌ Never use `X-Client-Token` (use lowercase `x-client-token`)
- ❌ Don't verify JWT tokens (only decode - no secret available)
- ❌ Don't use camelCase (use snake_case for Python) - **Exception**: ErrorResponse fields use camelCase (`statusCode`, `correlationId`)
- ❌ Don't skip type hints
- ❌ Don't skip docstrings for public methods
- ❌ Don't log sensitive data (use DataMasker)
- ❌ Don't fail requests if Redis is unavailable (gracefully fallback)
- ❌ Never expose stack traces or internal error details to client code
- ❌ Don't expose sensitive information in error messages (database queries, paths, etc.)
- ❌ Don't use snake_case for error response fields (use camelCase: `statusCode`, not `status_code`)

---

**Remember**: Security is not optional. Every line of code must be written with security and compliance in mind. When in doubt, choose the more secure option and document the decision.
